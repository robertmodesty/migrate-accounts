#!/bin/bash

# ******* Under here are list of readonly variables *******

readonly Old_Filesystem="$1"
readonly Regular_GroupID_Boundray="500"

#   setup in function analysis_args():
#       readonly FirstAccount
#       readonly LastAccount
#       readonly Old_passwd
#       readonly Old_shadow
#       readonly Old_group
#       readonly Old_gshadow
#       readonly LoginShell
#       readonly Flag_No_Eff_Grp

#   setup in function process_readonly_variables():
#       readonly Old_passwd_Content
#       readonly Old_shadow_Content
#       readonly Old_group_Content
#       readonly Old_gshadow_Content
#       readonly MigratoryAccGrpPairs
#       readonly MigratoryAccounts
#       readonly MigratoryInitialGroups
#       readonly MigratoryEffectiveGroups






####################
# General Functions:  Field Operation
########################################################################

function cut_field() {
  local -i step field=$1
  local x

  if [ -n "$2" ] ; then
    x="$2"
    for (( step=1 ; step<field ; step++ )) ; do
      x=${x#*:}
    done
    echo "${x%%:*}"

  else
    while read x ; do
      for (( step=1 ; step<field ; step++ )) ; do
        x=${x#*:}
      done
      echo "${x%%:*}"
    done
  fi
}

function grep_field() {
  local -i step field=$1
  local inFile=0 pattern="$2" retrnVal=1 y

  if [ -n "$3" ] ; then
    inFile=9
    exec 9< "$3"
  fi

  while read -u $inFile x ; do
    y="$x"
    for (( step=1 ; step<field ; step++ )) ; do
      y=${y#*:}
    done
    if [ "$pattern" == "${y%%:*}" ] ; then
      echo "$x"
      retrnVal=0
    fi
  done

  exec 9<&-
  return $retrnVal
}




####################
# General Functions:  Account and Group Operation
########################################################################

function is_old_initial_group() {
  local oldInitGrps=" $( echo $MigratoryInitialGroups ) "

  test "${oldInitGrps}" != "${oldInitGrps#* $1 }"
  return $?
}

function is_migratory_user() {

  echo "$MigratoryAccounts" \
   | grep_field 1 $1 > /dev/null
}

function is_valid_user() {
  local x

  exec 3< /etc/passwd
  while read -u 3 x ; do
    if [ "${x#$1:}" != "$x" ] ; then
      exec 3<&-
      return 0
    fi
  done
  exec 3<&-
  return 1
}

function is_valid_group() {
  local x

  exec 3< /etc/group
  while read -u 3 x ; do
    if [ "${x#$1:}" != "$x" ] ; then
      exec 3<&-
      return 0
    fi
  done
  exec 3<&-
  return 1
}

function old_effective_groups_of_user() {
  local userName="$1"
  local x effMembrs membr

  echo "$Old_group_Content" \
   | while read x ; do

    effMembrs="${x##*:},"
    membr="${effMembrs%%,*}"
    effMembrs="${effMembrs#*,}"

    while [ -n "$membr" ] ; do
      if [ "$membr" == "$userName" ] ; then
        echo "${x%%:*}"
        break
      fi
      membr="${effMembrs%%,*}"
      effMembrs="${effMembrs#*,}"
    done

  done
}

function get_user_comment() {

  echo "$Old_passwd_Content" \
    | grep_field 1 "$1" \
    | cut_field 5
}

function get_user_initial_group() {
  local x

  for x in $MigratoryAccGrpPairs ; do
    if [ "$1" == "${x#*:}" ] ; then
      echo "${x%:*}"
      break
    fi
  done
}

function get_user_unshadow_password() {

  echo "$Old_passwd_Content" \
    | grep_field 1 "$1" \
    | cut_field 2
}

function old_home_directory_of_user() {

  echo "$Old_passwd_Content" \
    | grep_field 1 "$1" \
    | cut_field 6
}

function old_groupID_of() {

  echo "$Old_group_Content" \
    | grep_field 1 "$1" \
    | cut_field 3
}

function name_of_old_userID() {

  echo "$Old_passwd_Content" \
    | grep_field 3 "$1" \
    | cut_field 1
}

function name_of_old_groupID() {

  echo "$Old_group_Content" \
    | grep_field 3 "$1" \
    | cut_field 1
}






####################
# functions prepare readonly variable data
########################################################################

function sort_old_passwd_file_by_uid() {

  sort -t : -k 3 -n "$Old_passwd"
}

function sort_old_group_file_by_gid() {

  sort -t : -k 3 -n "$Old_group"
}

function get_old_accounts_and_initial_groups() {
  local x y userID groupID

  echo "$Old_passwd_Content" \
   | while read x ; do
    userID="$( cut_field 3 "$x" )"
    if [   $userID -ge $FirstAccount \
        -a $userID -le $LastAccount ] ; then
      groupID="$( cut_field 4 "$x" )"
      echo -n "${x%%:*}:"
      echo "$Old_group_Content" \
       | grep_field 3 "$groupID" \
       | cut_field 1
    fi
  done
}

function get_old_accounts() {

  echo "$MigratoryAccGrpPairs" \
   | cut_field 1
}

function get_old_initial_groups() {

  echo "$MigratoryAccGrpPairs" \
   | cut_field 2 \
   | sort \
   | uniq
}

function get_old_effective_groups() {
  local user

  for user in $MigratoryAccounts ; do
    old_effective_groups_of_user $user
  done \
   | sort \
   | uniq
}

function remove_old_system_groups() {
  local group groupID

  while read group ; do
    groupID="$( old_groupID_of $group )"
    test $groupID -ge $Regular_GroupID_Boundray && echo $group
  done
}




####################
# functions for migrating passwords and data
########################################################################

function passwd_content_after_migration() {
  local row user password

  exec 5< /etc/passwd

  while read -u 5 row ; do
    user="${row%%:*}"

    if is_migratory_user $user ; then
      password="$( get_user_unshadow_password $user )"
      row="${row#*:}"
      row="$user:$password:${row#*:}"
      echo "$row"

    else
      echo "$row"
    fi

  done

  exec 5<&-
}

function shadow_content_after_migration() {
  local row user

  exec 5< /etc/shadow

  while read -u 5 row ; do
    user="${row%%:*}"

    if is_migratory_user $user ; then
      echo "$Old_shadow_Content" \
       | grep_field 1 "$user"
    else
      echo "$row"
    fi

  done

  exec 5<&-
}

function userID_changing_table() {
  local new_name_and_ID row name oldID newID

  new_name_and_ID="$( \
   cat /etc/passwd \
    | cut -d ':' -f 1,3 )"
  new_name_and_ID=" $( echo $new_name_and_ID ) "

  echo "$Old_passwd_Content" | while read row ; do
    name="${row%%:*}"
    row="${row#*:}"
    row="${row#*:}"
    oldID="${row%%:*}"
    row="${new_name_and_ID#* $name:}"
    if [ "$row" != "$new_name_and_ID" ] ; then
      newID="${row%% *}"
      if [ "$oldID" != "$newID" ] ; then
        echo -n " [$oldID]=\"$newID\""
      fi
    fi
  done
}

function groupID_changing_table() {
  local new_name_and_ID row name oldID newID

  new_name_and_ID="$( \
   cat /etc/group \
    | cut -d ':' -f 1,3 )"
  new_name_and_ID=" $( echo $new_name_and_ID ) "

  echo "$Old_group_Content" | while read row ; do
    name="${row%%:*}"
    row="${row#*:}"
    row="${row#*:}"
    oldID="${row%%:*}"
    row="${new_name_and_ID#* $name:}"
    if [ "$row" != "$new_name_and_ID" ] ; then
      newID="${row%% *}"
      if [ "$oldID" != "$newID" ] ; then
        echo -n " [$oldID]=\"$newID\""
      fi
    fi
  done
}





####################
# functions of all steps
########################################################################

function exit_if_no_root_permission() {

  if [ "$(id -u)" != "0" ]; then
    echo "This script must be run with root permission!" 1>&2
    exit 1
  fi
}


function analysis_args() {

  if [   ! -d "$Old_Filesystem" ] ; then
    echo "'$Old_Filesystem' is not a directiory." 1>&2
    exit 1
  fi

  shift

  while [ -n "$1" ] ; do
    case "$1" in
      "--start="*)
        readonly FirstAccount="${1:8}"
        ;;
      "--end="*)
        readonly LastAccount="${1:6}"
        ;;
      "--passwd="*)
        readonly Old_passwd="${1:9}"
        ;;
      "--shadow="*)
        readonly Old_shadow="${1:9}"
        ;;
      "--group="*)
        readonly Old_group="${1:8}"
        ;;
      "--gshadow="*)
        readonly Old_gshadow="${1:10}"
        ;;
      "--loginshell="*)
        readonly LoginShell="${1:13}"
        ;;
      "--no-eff-grp")
        readonly Flag_No_Eff_Grp=1
        ;;
    esac
    shift
  done

  test -z "$FirstAccount" && readonly FirstAccount=500
  test -z "$LastAccount"  && readonly LastAccount=65533
  test -z "$Old_passwd"   && readonly Old_passwd="$Old_Filesystem/etc/passwd"
  test -z "$Old_shadow"   && readonly Old_shadow="$Old_Filesystem/etc/shadow"
  test -z "$Old_group"    && readonly Old_group="$Old_Filesystem/etc/group"
  test -z "$Old_gshadow"  && readonly Old_gshadow="$Old_Filesystem/etc/gshadow"
  test -z "$LoginShell"   && readonly LoginShell=/bin/bash

  test ! -f "$Old_passwd"  && echo "'$Old_passwd' is not a file."  && exit 1
  test ! -f "$Old_shadow"  && echo "'$Old_shadow' is not a file."  && exit 1
  test ! -f "$Old_group"   && echo "'$Old_group' is not a file."   && exit 1
  test ! -f "$Old_gshadow" && echo "'$Old_gshadow' is not a file." && exit 1
}


function process_readonly_variables() {

  readonly Old_passwd_Content="$( sort_old_passwd_file_by_uid )"

  readonly Old_shadow_Content="$( cat $Old_shadow )"

  readonly Old_group_Content="$( sort_old_group_file_by_gid )"

  readonly Old_gshadow_Content="$( cat $Old_gshadow )"

  readonly MigratoryAccGrpPairs="$( get_old_accounts_and_initial_groups )"
  if [ -z "$MigratoryAccGrpPairs" ] ; then
    echo Can not find any migratory account!
    exit 1
  fi

  readonly MigratoryAccounts="$( get_old_accounts )"

  readonly MigratoryInitialGroups="$( get_old_initial_groups )"

  if [ "$Flag_No_Eff_Grp" != "1" ] ; then
    readonly MigratoryEffectiveGroups="$( \
      get_old_effective_groups \
       | remove_old_system_groups \
    )"
  fi

}


function check_account_group_names() {
  local Vaccs VInitGrps VEffGrps x notClean

  Vaccs="$(
    for x in $MigratoryAccounts ; do
      if is_valid_user $x ; then echo "$x" ; fi
    done
  )"

  VInitGrps="$(
    for x in $MigratoryInitialGroups  ; do
      if is_valid_group $x ; then echo "$x" ; fi
    done
  )"

  VEffGrps="$(
    for x in $MigratoryEffectiveGroups ; do
      if is_valid_group $x ; then echo "$x" ; fi
    done
  )"

  if [ -n "$Vaccs" ] ; then
    echo These users had been already added:
    echo
    echo $Vaccs
    echo
    notClean="1"
  fi

  if [ -n "$VEffGrps" ] ; then
    echo These effective groups had been already builded:
    echo
    echo $VEffGrps
    echo
  fi

  if [ -n "$VinitGrps" ] ; then
    echo These initial groups had been already builded:
    echo
    echo $VinitGrps
    echo
  fi

  if [ -n "$VEffGrps" -o -n "$VinitGrps" ] && [ "1" != "$notClean" ] ; then
    read -p "Will this be fine? (Y/n) " x
    x="${x^^}"

    while [ "Y" != "${x:=Y}" -a "N" != "$x" ] ; do
      read -p "Please insert 'Y' or 'N': " x
      x="${x^^}"
    done

    test "N" == "$x" && notClean="1"
  fi

  test "1" == "$notClean" && exit 1
}


function check_if_home_directorys_exist() {
  local user homeDirectorys

  homeDirectorys="$(
    for user in $MigratoryAccounts ; do
      if [ -e "/home/$user" ] ; then echo "$user" ; fi
    done
  )"

  if [ -n "$homeDirectorys" ] ; then
    echo These home directory is already exist:
    echo
    echo "$homeDirectorys"
    echo
    echo Please correct it.
    exit 1
  fi
}


function buile_accounts() {
  local user comment initGrp password shadowData

  for user in $MigratoryAccounts ; do

    comment="$( get_user_comment $user )"
    initGrp="$( get_user_initial_group $user )"

    is_valid_group $initGrp || groupadd $initGrp
    useradd -m -c "$comment" -g $initGrp -s $LoginShell $user

  done
}


function migrate_passwords() {
  local temp

  temp="$( passwd_content_after_migration )"
  echo "$temp" > /etc/passwd

  temp="$( shadow_content_after_migration )"
  echo "$temp" > /etc/shadow
}


function build_effective_groups() {
  local x

  for x in $MigratoryEffectiveGroups ; do
    is_valid_group $x || groupadd $x
  done
}


function set_effective_groups() {
  local user effGroups effGrp

  for user in $MigratoryAccounts ; do
    effGroups="$( old_effective_groups_of_user $user )"
    for effGrp in $effGroups ; do
      is_valid_group $effGrp && usermod -a -G $effGrp $user
    done
  done
}


function copy_home_directorys() {
  local user oldHome filename when_empty_home=false
  local old_ownerID old_groupID new_ownerID new_groupID

  eval local -a newID_of_old_userID_=( $( userID_changing_table ) )
  eval local -a newID_of_old_groupID_=( $( groupID_changing_table ) )

  echo -n "copy:  "
  for user in $MigratoryAccounts ; do
    oldHome="$Old_Filesystem/$(old_home_directory_of_user $user)"
    if [ "$(echo $oldHome/*)" == "$oldHome/*" ] ; then
      ! $when_empty_home \
        && echo -en "\nThese users have empty home directorys:  " \
        && when_empty_home=true
      echo -n "$user "
      continue
    else
      $when_empty_home && echo -ne "\ncopy:  " && when_empty_home=false
    fi
    echo -n "$user "

    cp -a $oldHome/* /home/$user

    find /home/$user/* -printf "%U:%G:%p\n" \
     | while read filename ; do

      old_ownerID="${filename%%:*}"
      filename="${filename#*:}"
      old_groupID="${filename%%:*}"
      filename="${filename#*:}"
      new_ownerID="${newID_of_old_userID_[$old_ownerID]}"
      new_groupID="${newID_of_old_groupID_[$old_groupID]}"

      if [ -n "$new_ownerID" ] ; then
        if [ -n "$new_groupID" ] ; then
          chown -h $new_ownerID:$new_groupID "$filename"
        else
          chown -h $new_ownerID "$filename"
        fi
      elif [ -n "$new_groupID" ] ; then
        chgrp -h $new_groupID "$filename"
      fi

    done

  done
  echo
}





####################
#  Main Function
########################################################################

function main() {

  exit_if_no_root_permission

  echo "Preparing..."
  analysis_args "$@"

  process_readonly_variables

  check_account_group_names

  check_if_home_directorys_exist

  echo "Building accounts..."
  buile_accounts

  echo "Migrating passwords..."
  migrate_passwords

  if [ "$Flag_No_Eff_Grp" != "1" ] ; then
    echo "Building effective groups..."
    build_effective_groups
    echo "Setting user's effective groups..."
    set_effective_groups
  fi

  echo "Copying home directorys of users..."
  copy_home_directorys

}





##### Start this program ######

main "$@"
