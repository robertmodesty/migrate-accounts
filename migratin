#!/bin/bash

# ******* Under here are list of readonly variables *******

readonly Old_Filesystem="$1"
NewLine="$( echo -e "0\n0" )"
readonly NewLine="${NewLine//0/}"


#   setup in function analysis_args():
#       readonly FirstAccount
#       readonly LastAccount
#       readonly ListFile
#       readonly Old_passwd
#       readonly Old_shadow
#       readonly Old_group
#       readonly Old_gshadow
#       readonly Old_maildir
#       readonly if_migrat_Eff_Grp
#       readonly if_cp_mails

#   setup in function process_readonly_variables():
#       readonly Old_passwd_Content
#       readonly Old_group_Content
#       readonly MigratoryAccGrpPairs
#       readonly MigratoryAccTable
#       readonly MigratoryAccounts
#       readonly MigratoryInitialGroups
#       readonly MigratoryEffectiveGroups
#       readonly MigratoryEffGrpTable






####################
# General Functions:  Field Operation
########################################################################

function cut_field() {
  local -i step field=$1
  local x

  if [ -n "$2" ] ; then
    x="$2"
    for (( step=1 ; step<field ; step++ )) ; do
      x=${x#*:}
    done
    echo "${x%%:*}"

  else
    while read x ; do
      for (( step=1 ; step<field ; step++ )) ; do
        x=${x#*:}
      done
      echo "${x%%:*}"
    done
  fi
}

function grep_field() {
  local -i step field=$1
  local inFile=0 pattern="$2" retrnVal=1 y

  if [ -n "$3" ] ; then
    inFile=9
    exec 9< "$3"
  fi

  while read -u $inFile x ; do
    y="$x"
    for (( step=1 ; step<field ; step++ )) ; do
      y=${y#*:}
    done
    if [ "$pattern" == "${y%%:*}" ] ; then
      echo "$x"
      retrnVal=0
    fi
  done

  exec 9<&-
  return $retrnVal
}




####################
# General Functions:  Account and Group Operation
########################################################################

function is_old_initial_group() {
  local oldInitGrps=" $( echo $MigratoryInitialGroups ) "

  test "${oldInitGrps}" != "${oldInitGrps#* $1 }"
  return $?
}

function is_migratory_user() {

  echo "$MigratoryAccounts" \
   | grep_field 1 $1 > /dev/null
}

function is_valid_user() {
  local x

  exec 3< /etc/passwd
  while read -u 3 x ; do
    if [ "${x#$1:}" != "$1" ] ; then
      exec 3<&-
      return 0
    fi
  done
  exec 3<&-
  return 1
}

function is_valid_group() {
  local x

  exec 3< /etc/group
  while read -u 3 x ; do
    if [ "${x#$1:}" != "$1" ] ; then
      exec 3<&-
      return 0
    fi
  done
  exec 3<&-
  return 1
}

function effective_groups_of_user() {
  local userName="$1"
  local x effMembrs membr

  exec 9< "$Old_group"
  while read -u 9 x ; do

    effMembrs="${x##*:},"
    membr="${effMembrs%%,*}"
    effMembrs="${effMembrs#*,}"

    while [ -n "$membr" ] ; do
      if [ "$membr" == "$userName" ] ; then
        echo "${x%%:*}"
        break
      fi
      membr="${effMembrs%%,*}"
      effMembrs="${effMembrs#*,}"
    done

  done
  exec 9<&-
}

function get_user_comment() {

  grep_field 1 "$1" "$Old_passwd" \
    | cut_field 5
}

function get_user_initial_group() {
  local x

  for x in $MigratoryAccGrpPairs ; do
    if [ "$1" == "${x#*:}" ] ; then
      echo "${x%:*}"
      break
    fi
  done
}

function get_user_unshadow_password() {

  grep_field 1 "$1" "$Old_passwd" \
    | cut_field 2
}

function old_home_directory_of_user() {

  grep_field 1 "$1" "$Old_passwd" \
    | cut_field 6
}

function old_userID_of() {

  grep_field 1 "$1" "$Old_passwd" \
    | cut_field 3
}

function old_groupID_of() {

  grep_field 1 "$1" "$Old_group" \
    | cut_field 3
}

function name_of_old_userID() {

  grep_field 3 "$1" "$Old_passwd" \
    | cut_field 1
}

function name_of_old_groupID() {

  grep_field 3 "$1" "$Old_group" \
    | cut_field 1
}






####################
# functions prepare readonly variable data
########################################################################

function sort_old_passwd_file_by_uid() {

  sort -t : -k 3 -n "$Old_passwd"
}

function sort_old_group_file_by_gid() {

  sort -t : -k 3 -n "$Old_group"
}

function get_old_accounts_and_initial_groups() {
  local x y userID groupID

  exec 3< "$Old_passwd"
  while read -u 3 x ; do
    userID="$( cut_field 3 "$x" )"
    if [   $userID -ge $FirstAccount \
        -a $userID -le $LastAccount ] ; then
      groupID="$( cut_field 4 "$x" )"
      echo -n "${x%%:*}:"
      grep_field 3 "$groupID" "$Old_group" \
       | cut_field 1
    fi
  done
  exec 3<&-
}

function get_migratory_account_table() {
  local pairs userName initGroup

  echo "$MigratoryAccGrpPairs" \
   | while read pairs ; do
      userName="$( cut_field 1 $pairs )"
      initGroup="$( cut_field 2 $pairs )"
      echo -n "$userName:$( old_userID_of $userName )::"
      echo ":$initGroup:$( old_groupID_of $initGroup )::"
  done
}

function get_old_accounts() {

  echo "$MigratoryAccGrpPairs" \
   | cut_field 1
}

function get_old_initial_groups() {

  echo "$MigratoryAccGrpPairs" \
   | cut_field 2 \
   | sort \
   | uniq
}

function get_old_effective_groups() {
  local user

  for user in $MigratoryAccounts ; do
    effective_groups_of_user $user
  done \
   | sort
   | uniq
}

function get_effective_group_table() {
  local effGroup

  for effGroup in $MigratoryEffectiveGroups ; do
    echo "$effGroup:$( old_groupID_of $effGroup )::"
  done
}

function process_user_data_line(){
  local x="$1" tmp
  local oldUser newUserNam newUID newGrp

  x="$( echo $x )"
  test -z "$x" && reture 1

  x="${x%%#*}"
  x="$( echo $x )"
  test -z "$x" && reture 0

  oldUser="${x%%:*}"
  x="${x#*:}"
  newUserNam="${x%%:*}"
  x="${x#*:}"
  newUID="${x%%:*}"
  newGrp="${x#*:}"

  tmp="$( name_of_old_userID $oldUser )"
  test -n "$tmp" && oldUser="$tmp"

  test -z "$newUserNam" && newUserNam="$oldUser"

  if [-z "$newGrp" ] ; then
    tmp="$( grep_field 1 $oldUser | cut_field 4 )"
    newGrp="$( name_of_old_groupID $tmp )"
  fi

  MigratoryUserListFromFile+="$oldUser:$newUserNam:$newUID:$newGrp$NewLine"
}

function process_group_data_line(){
  local x="$1" tmp
  local oldGrp newGrpNam newGID

  x="$( echo $x )"
  test -z "$x" && reture 1

  x="${x%%#*}"
  x="$( echo $x )"
  test -z "$x" && reture 0

  oldGrp="${x%%:*}"
  x="${x#*:}"
  newGrpNam="${x%%:*}"
  newGID="${x#*:}"

  tmp="$( name_of_old_groupID $oldUser )"
  test -n "$tmp" && oldGrp="$tmp"

  test -z "$newGrpNam" && newGrpNam="$oldGrp"

  MigratoryGroupListFromFile+="$oldGrp:$newGrpNam:$newGID$NewLine"
}

function read_list_from_file() {
  local x err filename="$1"
  local -i count=0

  exec 3< "$filename"

  while read -u 3 x ; do
    case "$x" in
      "users:")
        while read -u 3 x ; do
          count=count+1
          process_user_data_line "$x"
          err="$?"
          test "$err" != "0" && break
        done
        ;;
      "groups:")
        while read -u 3 x ; do
          count=count+1
          process_group_data_line "$x"
          err="$?"
          test "$err" != "0" && break
        done
        ;;
    esac
    test  "$err" == "2" && err=fileError && break
  done

  exec 3<&-

  if [ "$err" == "fileError" ] ; then
    echo "Error reading file $filename on line $count:"
    echo "$x"
  fi
}




####################
# functions of all steps
########################################################################

function exit_if_no_root_permission() {

  if [ "$(id -u)" != "0" ]; then
    echo "This script must be run with root permission!" 1>&2
    exit 1
  fi
}


function analysis_args() {
  local unfile='is not a file.'
  local undir='is not a directiry.'

  if [   ! -d "$Old_Filesystem" ] ; then
    echo "'$Old_Filesystem' is not a directiory." 1>&2
    exit 1
  fi

  FirstAccount=500
  LastAccount=65533
  Old_passwd="$Old_Filesystem/etc/passwd"
  Old_shadow="$Old_Filesystem/etc/shadow"
  Old_group="$Old_Filesystem/etc/group"
  Old_gshadow="$Old_Filesystem/etc/gshadow"
  Old_maildir="$Old_Filesystem/var/spool/mail"
  if_migrat_Eff_Grp="true"
  if_cp_mails="false"

  shift

  while [ -n "$1" ] ; do
    case "$1" in
      "--start="*)
        FirstAccount="${1:8}"
        ;;
      "--end="*)
        LastAccount="${1:6}"
        ;;
      "--passwd="*)
        Old_passwd="${1:9}"
        ;;
      "--shadow="*)
        Old_shadow="${1:9}"
        ;;
      "--group="*)
        Old_group="${1:8}"
        ;;
      "--gshadow="*)
        Old_gshadow="${1:10}"
        ;;
      "--maildir="*)
        Old_maildir="${1:10}"
        if_cp_mails="true"
        ;;
      "--no-eff-grp")
        if_migrate_Eff_Grp="false"
        ;;
      "-m"|"--copy-mails")
        if_cp_mails="true"
        ;;
      "--listfile="*)
        ListFile="${1:11}"
        ;;
    esac
    shift
  done

  readonly FirstAccount LastAccount Listfile
  readonly Old_passwd Old_shadow Old_group Old_gshadow
  readonly Old_maildir if_migrat_Eff_Grp if_cp_mails

  test ! -f "$Old_passwd"  && echo "'$Old_passwd' $unfile"  && exit 1
  test ! -f "$Old_shadow"  && echo "'$Old_shadow' $unfile"  && exit 1
  test ! -f "$Old_group"   && echo "'$Old_group' $unfile"   && exit 1
  test ! -f "$Old_gshadow" && echo "'$Old_gshadow' $unfile" && exit 1
  test ! -d "$Old_maildir" && $if_cp_mails && \
      echo "'$Old_maildir' $undir" && exit 1
}


function process_readonly_variables() {

  readonly Old_passwd_Content="$( sort_old_passwd_file_by_uid )"

  readonly Old_group_Content="$( sort_old_group_file_by_gid )"

  readonly MigratoryAccGrpPairs="$( get_old_accounts_and_initial_groups )"
  if [ -z "$MigratoryAccGrpPairs" ] ; then
    echo Can not find any migratory account!
    exit 1
  fi

  readonly MigratoryAccTable="$( get_migratory_account_table )"

  readonly MigratoryAccounts="$( get_old_accounts )"

  readonly MigratoryInitialGroups="$( get_old_initial_groups )"

  if $if_migrate_Eff_Grp ; then

    readonly MigratoryEffectiveGroups="$( get_old_effective_groups )"

    readonly MigratoryEffGrpTable="$( get_effective_group_table )"

  fi
}


function check_account_group_names() {
  local Vaccs VInitGrps VEffGrps x notClean

  Vaccs="$(
    for x in $MigratoryAccounts ; do
      if is_valid_user $x ; then echo "$x" ; fi
    done
  )"

  VInitGrps="$(
    for x in $MigratoryInitialGroups  ; do
      if is_valid_group $x ; then echo "$x" ; fi
    done
  )"

  VEffGrps="$(
    for x in $MigratoryEffectiveGroups ; do
      if is_valid_group $x ; then echo "$x" ; fi
    done
  )"

  if [ -n "$Vaccs" ] ; then
    echo These users had been already added:
    echo
    echo $Vaccs
    echo
    notClean="1"
  fi

  if [ -n "$VEffGrps" ] ; then
    echo These effective groups had been already builded:
    echo
    echo $VEffGrps
    echo
    echo Please correct it before migration.
  fi

  if [ -n "$VinitGrps" ] ; then
    echo These initial groups had been already builded:
    echo
    echo $VinitGrps
    echo
  fi

  if [ -n "$VEffGrps" -o -n "$VinitGrps" ] && [ "1" != "$notClean" ] ; then
    read -p "Will this be fine? (Y/n) " x
    x="${x^^}"

    while [ "Y" != "${x:=Y}" -a "N" != "$x" ] ; do
      read -p "Please insert 'Y' or 'N': " x
      x="${x^^}"
    done

    test "N" == "$x" && notClean="1"
  fi

  test "1" == "$notClean" && exit 1
}


function check_if_home_directorys_exist() {
  local user homeDirectorys

  homeDirectorys="$(
    for user in $MigratoryAccounts ; do
      if [ -e "/home/$user" ] ; then echo "$user" ; fi
    done
  )"

  if [ -n "$homeDirectorys" ] ; then
    echo These home directory is already exist:
    echo
    echo "$homeDirectorys"
    echo
    echo Please correct it.
    exit 1
  fi
}


function buile_accounts() {
  local user comment initGrp password shadowData

  for user in $MigratoryAccounts ; do

    comment="$( get_user_comment $user )"
    initGrp="$( get_user_initial_group $user )"

    if ! is_valid_group $initGrp ; then
      groupadd $initGrp
    fi
    useradd -m -p 00000000 -c "$comment" -g $initGrp $user

    password="$( get_user_unshadow_password $user )"
    sed -i "s/^$user:[^:]*/$user:$password/" /etc/passwd

    shadowData="$( grep_field 1 "$user" "$Old_shadow" )"
    if [ -n "$shadowData" ] ; then
      sed -i "s/^$user:.*/$shadowData/" /etc/shadow
    fi

  done
}


function build_effective_groups() {
  local x

  for x in $MigratoryEffectiveGroups ; do
    if ! is_valid_group $x ; then groupadd $x ; fi
  done
}


function set_effective_groups() {
  local user effGroups effGrp

  for user in $MigratoryAccounts ; do
    effGroups="$( effective_groups_of_user $user )"
    for effGrp in $effGroups ; do
      usermod -a -G $effGrp $user
    done
  done
}


function copy_home_directorys() {
  local user filename ownerID groupID

  for user in $MigratoryAccounts ; do

    cp -a $Old_Filesystem/$(old_home_directory_of_user $user)/* /home/$user

    find /home/$user/* -printf "%U:%G:%p\n" \
     | while read filename ; do
      ownerID="${filename%%:*}"
      filename="${filename#*:}"
      groupID="${filename%%:*}"
      filename="${filename#*:}"
      chown $(name_of_old_userID $ownerID):$(name_of_old_groupID $groupID) \
              "$filename"
    done

  done
}


function copy_mails() {
  local mailFile filename ownerID

  cd $Old_maildir

  ls | while read mailFile ; do
    if is_migratory_user $mailFile ; then
      cp -a $mailFile /var/spool/mail/
      find /var/spool/mail/$mailFile -printf "%U:%p\n" \
       | while read filename ; do
        ownerID="${filename%%:*}"
        filename="${filename#*:}"
        chown $(name_of_old_userID $ownerID):mail "$filename"
      done
    fi
  done

  cd -
}





####################
#  Main Function
########################################################################

function main() {

  exit_if_no_root_permission

  analysis_args "$@"

  process_readonly_variables

  check_account_group_names

  check_if_home_directorys_exist

  buile_accounts

  if $if_migrate_Eff_Grp ; then
    build_effective_groups
    set_effective_groups
  fi

  copy_home_directorys

  $if_cp_mails && copy_mails

}





##### Start this program ######

main "$@"
